\documentclass[a4paper,11pt,titlepage]{article}
\usepackage[a4paper]{geometry}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{color}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{latexsym}
\usepackage[utf8]{inputenc}
\usepackage{longtable}
\usepackage{enumitem}
\usepackage{wrapfig}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{tabu}
\usepackage{url}
\usepackage{pdfpages}
\graphicspath{ {drafts/images/} }
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{frame=tb,
  language=Java,  
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
\begin{document}
\title{LondonSW: Traffic Simulator}
\author{Violetta Avkhukova\\Felix Santiago Anda Basabe\\Rawan Mohammed Alrahili\\Jia Liu\\Yakubu Aliyu Doma}
\maketitle
\tableofcontents
\newpage

\part{Introduction}
\paragraph{}
As population grows as a result of rapid development of cities, so does the volume of traffic and congestion. Managing traffic congestion is a serious issue, and with the ever-increasing volume of traffic, this problem is expected to get worse.
\paragraph{}
A simple description of traffic congestion is given as a situation where the volume of traffic surpasses the capacity of the road. However, the Department for Transport provides a more quantifiable description of congestion as "the average delay experienced for each kilometre travelled compared to driving at speeds typical when traffic is light" \cite{2}.
\paragraph{}
A lot of attention has been given to modelling and simulation of traffic flows to determine the causes of traffic congestion, to determine the effectiveness of traffic policies, and how such road policies can be improved and also aid in the development and design of road infrastructures.

\section{Problem Definition}
\paragraph{}
Many strategies have been proposed and implemented with the primary objective of relieving congestion. However, these strategies have varying effects and it is not always self-evident which strategy works best for a given scenario. A straightforward strategy is to construct new roads to increase the road capacity or improve already existing roads, but this rarely serves as a long time solution.
\paragraph{}
Congestion is described as self managing, that is; as the capacity of the road increases, so does the traffic demand to fill the new capacity. This notion is described as Pigou-Knight analysis, which suggests improving road network capacity does not guarantee reduced congestion, on the contrary it can be counter-productive by making congestion worse \cite{1,2}. This strategy is regarded as one of the most expensive ways of dealing with congestion \cite{2}.
\paragraph{}
Traffic simulation is important because it allows very complex traffic models to be studied and analysed. In situations where evaluating analytical and numerical data is not sufficient enough, it provides a visual description, of both existing and future scenarios. Another huge importance of traffic simulation is that it enables us see the outcome changes to road infrastructure will have.

\section{Project Summary}
\paragraph{}
In this report, we give a detailed documentation of the process involved in developing a traffic simulation software. Our traffic simulation software consist of two parts: the simulation environment and the map builder. 
\paragraph{}
The first part of the system is the simulation environment where actual simulations run. This part allows a user to load a map and run a simulation on it with some number of vehicles. 
\paragraph{}
The second part of the system is the map making mode. This part of our system allows the user to create a map. It serves as an interface which provides all the necessary functionalities for designing road infrastructure (i.e lanes, intersections), which can then be parsed, loaded and executed in the simulation environment.
\paragraph{}
The rest of this report is structured as follows. In section 2, we review the various literature related to traffic simulation. Furthermore, we also review existing works related in this domain. We proceed to section 3 where we provide the description of our initial project requirements  and the design approach we have chosen.

\part{Review}
There exists a variety of traffic simulation models which are categorised in accordance with numerous criteria, one of such criterion is the level of detail. However, within the scope of this report, only the two more  general classifications are considered. These are: Macroscopic and Microscopic, which are also referred to as micro-simulation and macro-simulation. In this section, we give an analysis of the existing articles and literature related to the different classifications of traffic simulation models mentioned above.
\subsection{Macroscopic}
\paragraph{}
Macro-simulations use high-level mathematical models usually derived from fluid dynamics for the modelling of traffic flow \cite{Ali, Serge}.
In this modelling approach, all vehicle are treated in the same manner (i.e individual vehicles are not modelled) however, input and output variables such as speed, density and flow are used. There is no differentiation between individual vehicles and there are usually no options of vehicle types in this approach.
\paragraph{}
Macroscopic models lack the ability of modelling complex road networks, complicated traffic features or vehicle behaviour. Therefore, they are more widely used for scenarios that do not require detailed modelling such as motorway networks \cite{Schulze}.
\subsection{Microscopic}
Unlike Macro-simulations, micro-simulations model individual entities separately at a very high level of detail and are classified as discrete models. Vehicle interactions with other vehicles and the environment are tracked, where interactions are governed by car-following or lane changing logic \cite{Ali}. Rules are set aside, to govern what action are permitted and what action are not permitted in the simulation. Microscopic simulations provide a more realistic modelling  traffic flow compared to the macroscopic due to the ability of modelling vehicles individually. Therefore microscopic simulations are ideal in the analysis of new or existing traffic policies \cite{Ali, Femke}.
\paragraph{}
The car-following model, also known as the time-continuous model is a categorisation of micro simulation. All car-following models are characterized using differential equations that  describe the entire dynamics of vehicle positions and their velocities. This model assumes that drivers input stimuli is restricted to their own velocity, the velocity of the leading vehicle, and their distance to the leading vehicle. The driving behaviour of a vehicles in this model might not only depend on the current vehicle in front, but the number of vehicles in front \cite{macrosim}.
\paragraph{}
Another way of implementing micrcoscopic simulations is through agent based modelling. This approach allows many scenarios to be modelled efficiently because each individual in the scenario can be represented as an agent, with a set of rules governing their behaviour. Agents can be programmed with behaviours, so as to allow individuals' behaviour to be similar to those of the entities they are modelling. Though the programmed behaviour given to agents is often simple however, when agents are simulated as a group, the often exhibit new behaviours \cite{2}.
Therefore agent based simulations are ideal for developing new models  because parameters of individuals can be changed easily to observe results.
\paragraph{}
Cellular automata models are another categorization of microscopic models.The difference between the cellular automaton and the car following is that, cellular automaton is space discrete. In this model, roads are composed or series of cells, where each cell is either empty or occupied by a vehicle. Vehicle movement is restricted by the vehicle in front. That is, vehicles are only able to move forward when the next cell is unoccupied. Certain rules are defined  to determine when a vehicle moves to the next cell. This method is said to be very efficient due to its simple array structure \cite{Ali}.

\part{Requirements and Design}
\paragraph{}
Prior to embarking on the design of the system, we researched the different traffic simulation models for better understanding of the domain, from which an appropriate model was chosen for our simulation software.
In this section, we describe the requirements we set out for our project and the design choices taken to meet these requirements.
\section{Requirements}
\paragraph{}
To make development easier, priorities must be emphasised on the most important aspects of software. To achieve this, we hierarchically structured our aims using the MoSCoW prioritization method. This was used to classify the aims of the project into various levels of importance as presented:
\begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt
	\item{Must}
		\begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt
			\item{Adopt and adhere to cellular automaton model}
			\item{Entry and exit  points for vehicles}
			\item{Free movement and turning of vehicles}
			\item{Traffic light functions}
			\item{Default map}
			\item{Display simple animation of vehicle movement}
		\end{enumerate}
	\item{Should}
		\begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt
			\item{Users' can create and save maps}
			\item{Traffic policies}
			\item{Import pre-made maps}
			\item{Control for simulation, i.e number of vehicle and simulation speed}
			\item{Prioritize emergency services}
		\end{enumerate}
	\item{Could}
		\begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt
			\item{Statistics, i.e time spent at traffic light e.t.c}
			\item{Curve roads}
			\item{External map sources, e.g OpenStreetMap, Google Maps }
		\end{enumerate}
\end{enumerate}
\paragraph{}
Requirements under the "Must" classification are extremely important features of our system. They are the minimum building block of our simulation. That is, they are the minimum required features that must be implemented for the basic functioning of the system. Features in the next classification are also important because they provide added value to the system. However, the basic functioning of the overall system does not rely on them therefore not all features here might be present due certain constraints. Finally, the features listed on the last classification category "Could" are features which we regard to as non-functional however, if implemented provide additional functionalites.
\section{Design}
\paragraph{}
To design systems accurately, a correct system architecture is extremely important. It aids in ensuring that all requirement of a system are fulfilled and further helps with scalability, to meet future requirements.
Our system was designed upon a simple form of microscopic traffic simulation known as the cellular automaton. This approach relies on updating vehicle positions based on a central timing clock (Ticker).
\paragraph{}
We opted for the Model-View-Controler architectural style for the design of our system. The M-V-C style allows us to separate concerns thats is, tasks are grouped into either model or view component depending on what functions they perform in the system.
\paragraph{}
The \textbf{\textit{model}} is responsible for maintaining domain knowledge. In our case, it encapsulates the cellular automaton logic which our system must adhere to. It also notifies the \textit{view} of changes in state.
The \textbf{\textit{view}} is responsible for displaying information to the user. It displays the logic encapsulated by the model and maps users' actions to the \textit{controller}. Finally, the \textbf{\textit{controller}} manages interactions with the user. That is, as no direct communication is possible from the \textit{view} to the \textit{model}, the \textit{controller} therefore responsible for mapping user actions to \textit{model} updates.
\paragraph{}
The singleton design pattern is also used for most controllers in the system. We decided use this design pattern because we only needed one instance of controller objects for manage each type of map component.

\part{Implementation}
\section{Map}
The Map class represents maps that the simulation runs on. Vehicles interact with the map by driving through roads that they choose. The sections below describe how this class is structured.
\subsection{The Basics}
\paragraph{}
There are a number of low-level basic controls that make our maps possible. They are listed and described below.
\subsubsection{Coordinates}
\paragraph{}
Our basic unit for positioning is the Coordinate class which contains a pair of integers which denote  x- and y-positions in a two dimensional coordinate system. The former represents the vertical axis and the latter represents the horizontal axis. This class is used by the whole system in many classes, like locations of intersections, vehicles, and the start and end points of roads and lanes.

Besides the getters and setters for the x- and y- positions, the most useful features are the overloading of the equals operator to enable Coordinate comparisons, addition and subtraction methods of Coordinates and the capability to add a step to a position regarding the cardinal direction.
\subsubsection{Components}
\paragraph{}
There is an interface in our system called Component that acts as a common denominator between objects that we are able to add to a map. We have two types of components, Roads and Intersections, but this can be expanded to more types if necessary. The actual interface is empty, because no common functionality is necessary between all components. It is most useful for the MapGrid class, which stores the underlying map structures as a 2d-array of Components. This makes storing and looping through map components easy. Like the Coordinate, the components are used widely in the whole system. To use components, we capture the object and cast it to an instance of either a Road or an Intersection, and then we are able to interact with the component treating it as the former or the latter. 
\subsection{Structure}
The map consists of three important components: a MapGrid instance, Roads, and Intersections. In general, a map consists of a mixture of roads and intersections that build a type of graph, where intersections are nodes and roads are directed edges between nodes. Each map has a constant width and height. The Map class has functions that allows communication with components deeper down the Map hierarchy, like Roads to Lanes to Cells. 
\paragraph{MapGrid}
The MapGrid class is the underlying structure of our Map. It contains a 2D-array of the Component instances, which can be Roads, Intersections or empty. The map grid has a width and height which represents the size of the map. An important method that it contains is "addComponent(Component c)" which takes a generic component and adds it to the grid structure.
\paragraph{Roads} For more information about roads in the map, refer to section \ref{roadsection} on page \pageref{roadsection}.
\paragraph{Intersections} For more information about intersections in the map, refer to section \ref{intersectionsection} on page \pageref{intersectionsection}.
\subsection{Testing}
\paragraph{}
We were able to test the model of our maps in a text-based fashion then subsequently when the relevant tests were passed, we were able to integrate it with a graphic user interface view.
\paragraph{}
\centerline{ \includegraphics[scale=0.5,natheight=542,natwidth=1246]{test_mapgrid.png}}

\section{Roads}\label{roadsection}
\subsection{Basic Structure}
\paragraph{}
A road is a container for one or more lanes with a start point and an end point of type Coordinate. Each road is connected to at most two intersections. Roads can be of size 1 to n and only can be drawn horizontally or vertically according to the start and end point locations. Our simulation system has limited the number of lanes to 2 with a left-hand driving traffic pattern. If we do not assign an intersection to the end of the road, the vehicle will leave the simulation after reaching the end.
\subsection{Lanes}
\paragraph{}
A lane is part of a road where the vehicles move. A lane's length is defined by the road it is in. The maximum number of cells that vehicles can be in is equal to the length of the lane. Vehicles enter the lanes at the start position and exit through the end position. Lanes are like queues that follow the cellular automata model, i.e. it is first-in-first-out and vehicles can only move forwards if the cell in front of them is empty. 
\paragraph{}
Lanes have a moving direction represented by the MapDirection enumeration, which consists of values NORTH, SOUTH, EAST, and WEST. We set this explicitly because if a lane has a length of 1, its start and end locations are the same, therefore making it impossible to determine which way traffic flows. When adding lanes to a road, the lanes travelling north must be added before the ones travelling south and the lanes travelling east must be added before the ones travelling west to maintain the left-hand style of driving.

\subsection{Evaluation}
\paragraph{}
We believe are roads are well implemented. They fulfill their task of holding a number of lanes without any excess overhead. However, a few possible improvements could be possible, such defining a better way of keeping track which lanes are moving in what direction. In other words, lane orientation in the map is defined only by the order in which lanes are added to the road. So if the requirement is to have left-hand side driving, then the north-moving lane must be added before the south-moving lane. Removing this kind of dependency could make it easier adding lanes to roads. Also, our system was only tested with roads with up to two lanes, so including support for more lanes would be possible.

\section{Traffic Lights}\label{trafficlights}
\subsection{Basic Structure}
\paragraph{}
The TrafficLight class implements traffic light functionality for the simulation. Each traffic light has a duration (how long it should last a single colour) and initial state (red or green). It subscribes to the Ticker upon creation. The nextState() method takes the state it is currently in and sets it to the state it should be in next.

\subsection{Ticker Interaction}
\paragraph{}
This is where most of the interesting implementation lies. Each traffic light holds an internal time. On each ticker tick, if its internal time is less than the duration, it increments its internal time. If it hits its duration, it changes to the next colour and resets its internal time. To tell the rest of the system of its colour change, it tells the traffic light controller of its new colour state.

\subsection{Traffic Light Controller and Traffic Light Decorator}
\paragraph{}
The TrafficLightController class is the link between the model TrafficLight class and the GUI representation. It follows the singleton pattern, and includes global variables like the duration of all traffic lights and whether or not the traffic lights are enabled. It also includes two "database" type objects: a HashMap, with each TrafficLight instance registering to its GUI representation, and an ArrayList that holds all TrafficLight instances.
\paragraph{}
The "colourChanged(LightColour colour, TrafficLight tl)" method gets called by the TrafficLight "tl" with the new "colour" it is. This method then uses "tl" and uses it as a key to look up its corresponding GUI representation, a TrafficLightDecorator, in the HashTable. TrafficLightDecorators contais a TrafficLight that it is representing and a JavaFX Circle shape. The circle is what changes colour upon request. First the circle is drawn, and when the "setGUIColour(LightColour colour)", the circle changes colour to the new colour.
\paragraph{}
The TrafficLightController contains helper methods for disabling and enabling all traffic Lights and changing the duration of all traffic lights.

\subsection{Evaluation}
\paragraph{}
We believe that using a HashTable to store (TrafficLight, TrafficLightDecorator) pairs in the controller was a good idea because of its $O(1)$ retrieval time. At first, we were unsure of how to have many intances of TrafficLights linked to TrafficLightDecorators. We first considered having many instances of the controller, but that did not make logical sense. Having the HashMap made it easier to look up which circles must change colour at any given time. However, a minor change that could be possible is removing the ArrayList of TrafficLight instances and only using the HashMap keys to get at a list of all traffic lights. This would remove a data redundancy.

\section{Intersections}\label{intersectionsection}
\subsection{Basic Structure}
\paragraph{}
An intersection is a special type of component that connects roads together. It connects at least two roads and a maximum of four. To represent the connections, the intersection has four variables, one for each road. Road positioning relative to that intersection instance is specified by the names of the variables. For example, a road that is north of the intersection gets set as the intersection's north road.
\paragraph{}
An intersection also contains up to four traffic lights. Traffic lights can be determined automatically by the method "setDefaultTrafficLightsForRoads()", which looks at each road that is set to the intersection and sees if there is a lane in that road that is driving towards the intersection. If there is such a lane, then the traffic light is added. To prevent all the traffic lights from starting with the same initial colour, north and south traffic lights start red, and west and east traffic lights start green. If there are no north or south lights, then the east and west traffic lights start at red. For more information about traffic lights, look at Section \ref{trafficlights} on page \pageref{trafficlights}.
\subsection{Intersection Controller and Decorator}
\paragraph{}
The intersections have a controller to act as a link between their model and view representations. A HashMap is used in the controller to keep a "database" where each intersection is registered with exactly one instance of an intersection GUI representation.
\paragraph{}
Each IntersectionDecorator class is associated with a single intersection instance. Each has up to 4 TrafficLightDecorators that live inside it. The Intersection does not have any explicit circles itself; it relies on the circles of each TrafficLightDecorator that is associated with each TrafficLight.
\paragraph{}
The most important functionality of the Intersection decorator is the drawIntersection method that draws the wrapped Intersection and produces a visual representation with traffic lights embodied in a stack pane:
\begin{lstlisting}
	public StackPane drawIntersection() {
		...
		return stackPane;	
	}
\end{lstlisting}
The locations for each traffic light are determined. Then, for each traffic light, if it is not null, its circle representation gets added to the interection GUI representation.
\subsection{Evaluation}
We believe that our intersections are well designed. At first, we were unsure of how to display up to four traffic lights at once. By embedding TrafficLightDecorators inside the IntersectionDecorator we were able to display all traffic light circles at once. There was an issue that we had to solve which involved only one of the circles changing colour, despite them all being visible and set to the correct initial states. This was solved by including a method in the TrafficLightDecorator class to return the circle to the IntersectionDecorator and have it manage the drawing and adding the actual circle to the view. This may have been a simple issue with JavaFX panes, because it was always the last added traffic light that would change colour. However, this way, there is a controller that manages combining a few traffic lights into one grid cell view. 

\section{Ticker}
\paragraph{}
The ticker class is how time is kept in the simulation system. It would start at zero and increment at a given time increment, or granularity, such as every one second. Any type of object that wants to do some operation at each time increment must subscribe to this class. The ticker publishes the time to all subscribers at every time increment. Typical subscribers include vehicles and traffic lights, although other objects can subscribe as well.
\paragraph{}
The Ticker class is located high up in the package hierarchy because of how central its role is. It was one of the tricker parts of the project implementation because we had to decide how to implement the publish-subscribe relationship and have the ticker ticking at a constant rate. The ticker had to once be re-worked because of some complexity that arose. However, the one aspect that remained constant was the importance of having the publish-subscribe relationship.
\subsection{First Implementation}
\subsubsection{Initial Stages}
\paragraph{}
In the first implementation of the Ticker class, important things had to be decided on, such as how to notify all subscribers of time changes and how to handle time ticking on a periodic basis. Because we were starting from scratch, we had nothing to base it on, so the design was one of the more difficult parts of the implementation.
\subsubsection{Basic Structure}
\paragraph{}
The Ticker class followed the singleton pattern, so that the number of instances would be capped at one. Any potential subscribers would implement an interface called TickerListener, which contained a method called "onTick(long time)" that needed to be implemented by the subscriber. This would be the method that would execute on every time increment in the ticker.
\subsubsection{Ticking Support}
\paragraph{}
The actual underlying ticking relied on two main aspects: a Timer instance and a TimerTask instance (both part of the java.util package). In general, a Timer instance executes a TimerTask instance at the specified interval. The Ticker class had a class embedded in it, called TickerRunnable which extended the TimerTask class. It also followed a singleton pattern for the constructor and it had a "run()" method that would execute when required by the Timer. This is where each subscriber would be notified with the current time in the simulation. To start the Ticker ticking, it had a method called "start()", which initiated the Timer and gave it the task of running the TickerRunnable at the given interval specified by the variable of type long named TICK\_INTERVAL. So overall, after every interval, the TickerRunnable would execute its "run()" method, which would tell all subscribers that the time changed, which would execute some operation. For instance, vehicles would move forwards.
\subsubsection{Evaluation}
\paragraph{}
The Ticker class performed well with the model elements of the project. In the test cases performed, vehicles would move properly and traffic lights would change colour. However, there were many issues that had to be resolved. Firstly, we did not like the way in which subscribers were notified of time ticks. The Ticker held a list of all its subscribers, which already violates the key property of the publish-subscribe relationship (publishers of events do not know who its subscribers are, nor should they care). Because of this list, on every tick, we would cycle through this list and notify each subscriber one at a time. This was not ideal because some subscribers would hear the tick before others. This made us think of how we could try to notify all subscribers at once.
\paragraph{}
Secondly, and more importantly, this implementation did not work with JavaFX threads. An exception would be thrown each time a thread other than the JavaFX thread would try to modify any graphical elements. This was first discovered when we tried to test the GUI representation of traffic lights. We would get the following exception:
\begin{lstlisting}
	Exception in thread "Timer-1" java.lang.IllegalStateException:
	Not on FX application thread; currentThread = Timer-1
\end{lstlisting}
This was a major cause for concern, because the goal was to have a fully functioning graphical user interface and not simply displaying vehicles in the console! At first, this was solved by a call to the JavaFX application platform, called Platform. It contains a method "runLater(Runnable r)" that takes any sort of runnable task \cite{platform}. This did make the animation work from the Ticker thread, but it was not ideal because it simply schedules the task for some "unspecified time in the future". Finally, a minor issue was that the Ticker had an instance, but all methods were static, so it made us think if having an instance was necessary at all. This is when we decided that the Ticker class must be re-worked in some other way, hence our second, and current, implementation.
\subsection{Second Implementation (Current)}
\subsubsection{Initial Stages}
\paragraph{}
Given the issues faced with the first implementation, we needed a Ticker that would work with the JavaFX thread and that would ideally notify all subscribers at the same time of the tick. We decided to research potential ways the Ticker could be implemented.
\subsubsection{Getting Help from Libraries}
\paragraph{ReactFX}
This is a library that helps by adding support for "reactive event streams" that works with JavaFX. In short, it processes events that happen in the system, such as clicks \cite{reactfx}. As the first solution, we used a type of event stream called "EventStreams.ticks(...)", which generated a tick after each time the given time  interval passes. This worked for small cases and test files using JavaFX, but due to lack of good documentation, we were unsure of how to proceed with this framework to support the whole simulation system. This library claimed to be inspired by RxJava, a more general reactive approach, so we investigated this next.
\paragraph{RxJava}
Made by ReactiveX and Netflix, this open-source library provides a reactive programming approach for Java \cite{rxjava}. By the word "reactive", it means that there are some objects that react to something else, which means that many reactions can execute in parallel. There are observers (which are subscribers) that listen to some Observable (the publisher). The observable emits some sort of object and the subscribers react to it when they get the message \cite{reactivex}. We decided to use this library as part of our implementation. Although this library can do many other things with event streams, like filtering or debouncing, we are only skimming the surface of its functionality and only using its publish-subscribe facilitation.
\paragraph{RxJavaFX}
Also made by ReactiveX, this is a library that allows an asynchronous reactive approach to JavaFX-specific events. It is useful for GUI event processing \cite{rxjavafx}. Although we decided to use this in our Ticker implementation, we are using a very small amount of its functionality. The only aspect of this library that we are using is specifying that the publisher/observable should run on the JavaFX application thread.

\subsubsection{Solution}
\paragraph{}
We decided to use a combination of RxJava and RxJavaFX for our Ticker implementation. The thing that does the ticking is defined as an Observable$<$Long$>$ from the RxJava package, rx. The type parameterization says that the message that this publisher sends is of type Long, so the current time in the system can be sent. Objects that wish to subscribe to the Ticker must extend the Subscriber$<$Long$>$ class, also from the rx package. This gives the subscriber three methods to implement: onCompleted(), which gets called once the Ticker terminates, onError(Throwable t), which gets called if there is an error with the Ticker, and most importantly, onNext(Long long), which gets called on every tick. Classes like Vehicle and TrafficLight implement this method to define functionality that must be performed on every tick. To subscribe to the observable's messages, each subscriber class is set to call Ticker.subscribe(...) in its constructor with itself as the parameter. This executes the following line for each subscriber:
\begin{lstlisting}[language=Java,breaklines=true,basicstyle=\small]
tickerObservable.takeUntil(stop).observeOn(JavaFxScheduler.getInstance()).subscribe(sub);
\end{lstlisting}
This tells the observable/publisher to subscribe the subscriber "sub" (a vehicle, traffic light, or anything else), to run it on the JavaFX thread, and to make it run until a stop signal is sent to it (it can still unsubscribe sooner than the signal). The resulting behaviour is that when there is a subscriber for the observable, the Ticker starts and the subscribers perform their onNext operations when a tick is sent out.

\subsubsection{Evaluation}
\paragraph{}
This approach works very well with the JavaFX thread because of explicitly specifying ".observeOn(JavaFxScheduler.getInstance())", thanks to RxJavaFx. It is simple to add more subscribers and have them perform some operation, thanks to RxJava. There are only a few downsides with this approach. First, the ticker speed must be set before the simulation begins. Once there is a subscriber, the ticker speed cannot change. For this reason, we request the user sets the ticker speed before beginning the simulation. It is possible in theory, but due to time constraints, we left it as-is. This requires calling Ticker.start() once the ticker speed is set to initialize the observable in-charge of ticking. Second, whatever class that wants to subscribe to the ticker must extend the Subscriber$<$Long$>$ class. Therefore, this would be the only class that the subscriber would be able to extend, as Java does not support multiple inheritance.

\section{Vehicles}
\paragraph{}
The simulation system is, after all, about vehicles and how they behave in different maps and conditions. This section will go in-depth into how vehicles move and the different types that are possible.
\subsection{The Vehicle Class}
\paragraph{}
Vehicle is abstract class that all vehicles implement; it enapsulates all generic vehicle behaviour. It being abstract allows for scalability because we can add more types of vehicles such as cars and ambulances. There are two types of vehicles: cars and ambulances, and both extend Vehicle.
\paragraph{}
Vehicles have a lot of attributes that are either global for all types of instances or are specific to an implementation. Attributes that define vehicles are: priority, behaviour, location, and state. Vehicle priority is represented by an integer, with 1 being the lowest. Vehicle behaviour is represented by an enumeration called VehicleBehaviour, with possible values of average, aggressive, or cautious. Coordinate location is determined dynamically by the "getCurrentCoordinate()" method. Finally, state is determined dynamically by calling all relevant vehicle movement methods and assigning it based on the outcome, which is based on the current state of the simulation.
\subsubsection{Car}
\paragraph{}
Instances of Cars are the most common in the simulation. This class extends the Vehicle class to gain all vehicle functionality but with some Car specific attributes. Cars represents basic vehicles, with basic vehicle behaviour. Cars are initialized with average behaviour and with the lowest priority of 1.
\subsubsection{Ambulance}
Instances of ambulances represent a vehicle with high priority. It is initialized with aggressive behaviour and a priority of 5, which is the highest in our system so far.
\subsection{Vehicle Movement and Ticker Interaction}
\paragraph{}
All significant vehicle behaviour is because of its interaction with the Ticker. On every tick by the ticker, the vehicle calls the VehicleController to move. The controller finds the corresponding VehicleDecorator, the GUI representation, in a HashMap of (Vehicle, VehicleDecorator) pairs. Then we begin processing the vehicle's request to move in the moveVehicle method.
\paragraph{}
Vehicles movement can be divided into two main categories: moving in a lane and turning to a new lane. Before any movement happens, we set the previous lane and coordinate of the vehicle to it's current lane and coordinate to keep track of.
\subsubsection{Moving in a lane}
Each lane is an array of vehicles, so the movement of vehicles is simply changing the vehicle's position in the lane by increasing its index by a number of steps. Vehicles only move forwards when the slot in front of them is empty. Cars possess AVERAGE behaviour so they will move one slot at a time. On the other hand, vehicles with AGGRESSIVE behaviour such as ambulances, move two steps each time if possible, otherwise they move one step.
To move it, we set the current cell in the lane to null, so other vehicles can move to this cell. We increase the vehicle's index in the lane by the number of steps it moved.
\subsubsection{Turning to a new lane}
After controlling the vehicle movement in a lane, we went to manage the movement of vehicles to other lanes. Vehicles can turn to a new lane only through intersections, which means it has to be at in the end of its current lane. To move to a new lane, there are three main things to consider: reading traffic lights, choosing the next lane to move to, and the ability to turn.
\paragraph{Reading traffic lights}
In our system, each road has two lanes, and each intersection can connect up to four Roads, which means each intersection can have up to four traffic lights. The readTrafficLight() method in the Vehicle class makes vehicles read only their corresponding traffic light. Reading the correct traffic light depends on the map direction of their lane. For example, if the map direction of a lane is south, and the vehicle is at the end of its lane, that means this vehicle is in the north road for of an intersection, so it has to read the north traffic light. If the traffic light is red, vehicle state is set to 0, which means the vehicle stops, and if it is green, vehicle state sets to 1, which means the vehicle can move. Vehicles with higher priority such as ambulances always can move even if the traffic light is red. After making vehicles listen to traffic lights, they can now choose a lane to go to.
\paragraph{Choosing the next lane to move to} 
Vehicles can only turn when they are at the end of the current lane. Vehicles reads the intersection in front if it and then read all roads connected to that intersection. From these roads, we take only go to lanes with a legal map direction for a given vehicle. For example, assume vehicle A is in a west road and its driving direction is East, and this vehicle want to move to the south road. For the south road, there are two lanes, one with north moving direction and the other with south moving direction. So, vehicle A can only choose lane which map direction is south. 
"getLaneOptions()" checks all connected lanes of an intersection and tests the validity of lanes in terms of the map direction and state. If the map direction is legal for a vehicle and the lane state is 1 (lane is enabled), this method puts the lane into the list. 
The "chooseLane()" method takes the array list of all valid lanes and chooses a random lane for the vehicle.
\paragraph{The Ability to Turn}
To avoid vehicle crashes in intersections when they turn, because they chose the same lane to go to, we have to regulate the vehicle movement in intersections. The first idea was to use vehicle IDs. Since each vehicle has a unique ID, we can compare them, so vehicles with higher IDs move, and others wait. After generating large numbers of vehicles on a map, we decided comparing IDs was not a good choice. If a vehicle at the front of a queue has an ID of 3, all vehicles behind that vehicle also have to wait for vehicles in the other lanes to pass. This made us give vehicles priorities to turn. We then had the idea giving vehicles at intersections a "vehiclePriorityToTurn" value, a random number from one to four, one for each possible vehicle at the intersection. The vehicle with the highest vehiclePriorityToTurn value moves, otherwise it waits.

We first made vehicles decide who will turn amongst themselves. 
By using priority, we need to give each vehicle a new priority each time they are at an intersection. Each vehicle gives other vehicles in the intersection priorities. Then each vehicle compares against the others. If there are two vehicles at an intersection, and each gives priority to the other, they both will try to move, so the problem still remains.

However, what we did next is implement "giveVehiclePriorities(ArrayList<Integer> randomPriority)" in the Intersection class, which makes random vehicle priorities generate at intersections, not vehicles. Therefore, the Intersection became a subscriber of the Ticker, so it can decide on each tick who will turn next.
The "vehicleTurnFirst(ArrayList<Vehicle> vehicles)" method in the Intersection class takes the array list of vehicles with priorities at the intersection as a parameter, compares the vehiclePriorityToTurn only for vehicles where their traffic light state is GREEN, then sets the vehiclePriorityToTurn to 1 for the  vehicle with the highest vehiclePriorityToTurn, or vehicles with vehiclePriority equal to 5 such as ambulances, otherwise sets to 0.

The final step to make vehicles turn is in "int vehicleTurn(Lane l)" method in Vehicle class. This method checks four things:
\begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt
\item If a vehicle is at the end of its lane.
\item If the chosen lane is not null.
\item If the first cell in the chosen lane is empty.
\item If vehiclePriorityToTurn equals to 1.
\end{enumerate}
If these conditions are obtained, the vehicle turns, otherwise it stops.

\paragraph{}
All movement methods, such as turning or moving straight, return an integer called "move". It is like a boolean, except with more information about the result. If move gets set to zero, that means the vehicle did not move and therefore we should not animate the vehicle movement. If move is greater than one, then the vehicle can be animated to move. If move was set to three, that means the vehicle should be removed from the simulation. All the movement methods may or may not actually move the vehicle in the model. When we go to do the vehicle animation, this is where the previous lane and coordinate come in. We must now animate the vehicle from its previous lane and coordinates, not its new ones, otherwise the vehicle would be moved twice. 

\subsection{Evaluation}
\paragraph{}
Making the Vehicle class an abstract class was a good idea because this makes our system extensible to new types of vehicles in the future. Fixing the vehicle movement bugs, namely when two vehicles would drive into the same lane at the same time, was a large accomplishment due to its real-time complexity. In terms of general vehicle movement, an area for improvement could be the steps taken to move. Maybe there is a better way of doing the animation, instead of setting the previous lane and coordinates and doing the animation based on that. 

Vehicles also do not know if there is an ambulance behind them. In future work, we would vehicles cleverer in their movement, so if there is an ambulance behind them they should have the higher vehiclePriorityToTurn, so ambulance can move faster.  Even though vehicles no longer crash, it would be better if more than one vehicle can move through an intersection at a time.

Vehicles can never go in the wrong lane in our system. However, making U-turn is not allowed yet in the system if they reach an intersection with no lane options.

Overall, we believe that the Vehicle class performs very well regarding the different states a vehicle can hold and the different movement results that can be returned. Therefore, vehicles are robust to any kind of map or driving conditions.

\section{Log}
\paragraph{}
The simulation system writes a log file with the corresponding timestamp each time the simulation starts. The log file name is with the form "Log\_Year-Month-Day-Hour-Minute-Second" and it gets stored in the "logs" directory in the working directory, i.e. where the source code is or where the executable is placed. Each object that is subscribed to the ticker is appended to the log with all its attributes. We are able to trace on each tick the activity generated by the object and it is useful for debugging processes, audits, and statistics.
\paragraph{}
To achieve the logging functionality we use the java.util.logging.Logger and we also extend the log class to the subscriber so it can interact easily with the Ticker to write the state of every subscriber on each tick.

\section{Testing the System}
\paragraph{}
Before we had our GUI screens, we tested the logic of our system using JUnit testing. In the src directory, we have a "test" package. This is where all of our test files went. We used JUnit tags such as @assertEquals(...), @assertNotNull(...), @Before(), and more. This allowed us to see whether the outputs we were expecting were achieved. 
\paragraph{}
However, tests involving the Ticker were done using main() methods, because we found that JUnit did not support multiple threads in its text environment. We researched into this some more, but found it easiest to use the main() methods in our test cases for our testing purposes. Additionally, once we had some GUI screens, we relied less on JUnit testing and more on integration testing using those screens.

\part{The Application}
\section{Start-Up}
\paragraph{}
When the user starts the system, they get presented with a start screen. After pressing the start button, the user gets presented with a choice of modes: opening a map or creating a new map. The screens are loaded using a series of controllers. A singleton instance of the StartUpController is made, which controls the first few screens.
\paragraph{}
Opening a map opens a File dialog where the user can open a pre-made map file. The simulation comes with some map files pre-built for the user. This then brings the user to the simulation screen. The StartUpController hands control to the SimulationController, which handles drawing the SimulationScreen. 
\paragraph{}
Choosing to make a map brings the user to the Map Maker screen. They choose a width and height of a map, place components on it, and save it as a new map. The user can then run the simulation on it. The StartUpController hands control to the MapMakerController, which handles drawing the MapMakerScreen.
\paragraph{}
This is a use-case diagram that describes the steps the user can take in our system:
\paragraph{}
\centerline{ \includegraphics[scale=0.5,natwidth=690,natheight=700]{UseCase.png}}

\section{Simulation Screen}
\paragraph{}
Aimed at making a user-oriented simulation system, we have a main simulation screen where users can both monitor the simulation process and control the simulation system by using various controls. Users would load maps from file to run the simulation on.
\subsection{Loading Maps}
\paragraph{}
When loading a map from file, we first had an issue where the traffic lights appeared, but never changed colour. This was fixed by making the traffic lights re-register with the Ticker and the TrafficLightController. Intersections also re-register with the Ticker.
\subsection{JavaFX Scene Builder}
\paragraph{}
JavaFX Scene Builder is a visual layout tool that lets users to quickly design JavaFX application user interfaces by dragging and dropping UI component to a work area, modifying their properties and applying style sheets. The FXML code which is automatically generated can be combined with Java projects by binding the UI to the application's logic to handle the events and actions taken on each element. At first, we chose JavaFX Scene Builder as our main GUI development tool.
\paragraph{}
Problems arose after we finished building FXML files and tried to connect the UI interface with simulation models. We found only one controller can be used in a FXML file which means we need to figure out how to communicate between different controllers. This problem first arose when we loaded pre-made maps into the simulation. 
\paragraph{}
Users need to choose a pre-made map before going into simulation screen, this needed an intermediate controller to deliver map name between two interfaces. There will be lots of this kind of communication so many intermediate controllers need to be added which could increase complexity. Thinking about this, we finally gave up JavaFX Scene Builder, decided to use pure JavaFX.

\subsection{Simulation Screen}
\paragraph{}
The simulation screen was built using Model-View-Controller (MVC) architecture pattern. SimulationController.java is the controller to draw the screen and generate the log for the simulation. SimulationScreen.java is the corresponding view used to manage UI components of the interface. The model is read from the Map components that are loaded.
\paragraph{}
We used the built-in layout container classes, called panes that are available with the JavaFX SDK to manage UI components of simulation screen. The JavaFX SDK provides several layout panes for the easy setup and management of classic layouts such as rows, columns, stacks, titles, and others. We used the BorderPane layout pane for the simulation screen. The BorderPane layout pane provides five regions in which to place nodes: top, bottom, left, right and center. 
\paragraph{}
To keep the interface simple, only three parts were used in our simulation screen: top, center and right. Title of the simulation screen "LondonSW Simulation System" was set on the top of the BorderPane. We used the center part to load the chosen pre-made map in which simulation process will happen. The right part was mainly used to monitor and control the simulation process. Here we used the VBox layout pane to make sure nodes are arranged in a single column. 
\paragraph{}
Labels including "Number of Cars", "Ticker interval", "Traffic Light Duration", "Time Ticked", "Vehicle Time Spent Standing" were set for simulation monitor to help users have a better understand about how is the simulation process going. 
\paragraph{}
"Start" and "Reset" buttons are used to control whether to start or stop the simulation process. Users can click "Add Ambulance" to add an ambulance whose behavior is aggressive and can also delete it. There is a "Set Traffic Light duration" button. Once it is clicked, there will be a dialog allows users to set traffic interval(100-1000 millisecond) by a spinner. "Disable Traffic Light" is used to delete all traffic lights of the map and "Enable Traffic Light" to restore all traffic lights to the map. This is to simulate situation in which traffic lights cannot work properly. 
\paragraph{}
We used a slider to control number of cars in the system. Users can set number of cars they want as long as it is in the available range. The minimum car number is 1, the maximum number is set automatically depends on the overall number of slots of all lanes in the map ($MaxCarNumber=0.6*SlotsNumber$). This means the simulation process won't crash due to too many cars results in no slot is available and to make sure the traffic can be coordinated properly. 
\paragraph{}
Generating cars is captured by the newValue the slider is set to. 
If oldValue is smaller than newValue, new cars $(newValue - oldVlue)$ would be generated to the map. 
Car generation happens with the "generateCar(...)" method. We get a random lane from the map, get an empty slot in that lane, and generate the vehicle there.
Otherwise, system would delete $(oldValue - newValue)$ cars randomly from the vehicle list. The vehicle gets deleted by calling the VehicleController method "removeVehicle(int i)". It removes a vehicle from the list of all vehicles at index i. The vehicle unsubscribes from the ticker, deletes itself from all databases, then gets set to null. Java garbage collection will then remove that instance completely.

\subsection{Map Graphics}
\paragraph{}
The whole Map grid layout consists on a GridPane which is a flexible grid of rows and columns that holds in each row and column a specific pane. Each cell is a StackPane, which can either be grass (empty square), a Road, or an Intersection. All drawings are of our own authorship because we have used the tool GIMP, an open source graphic editor \cite{gimp}. The size of each stack pane is dynamic and we are able to change it by changing a resize factor, which is an important attribute used in many of our drawings. 
\subsection{Decorators}
\paragraph{}
Our implementation is using the Decorator Pattern to extend the functionalities of each component so that the objects can be drawn by wrapping the original object and invoking a draw method for each component. There are 5 main wrappers MapGridGUIDecorator, IntersectionDecorator, RoadGUIDecorator, TrafficLightDecorator and VehicleGUIDecorator.
\subsubsection{MapGridGUIDecorator}
\paragraph{}
This is the class that manages the drawing of the entire map. By traversing the MapGrid representing the Map, we check what type of component is in each cell. We call the corresponding decorator class for that type of component. 
\subsubsection{RoadGUIDecorator}
\paragraph{}
The Road is a stack pane that has a rough grey background and the arrows of the lane representing which way traffic flows are drawn programatically in each square.
\subsubsection{IntersectionDecorator}
\paragraph{}
The intersection is drawn with the same background as a Road but in addition it has a yellow diagonal cross. For information about drawing intersections, please refer to section \ref{intersectionsection} on page \pageref{intersectionsection}.
\subsubsection{TrafficLightDecorator}
\paragraph{}
The traffic lights are also drawn programatically using its decorator class. For information about drawing traffic lights, please refer to section \ref{trafficlights} on page \pageref{trafficlights}.
\subsubsection{VehicleGUIDecorator}
Vehicle movement is displayed by using the VehicleGUIDecorator class. 
Each vehicle will have exactly one VehicleGUIDecorator associated with it. We have defined different states of the vehicle so we can track their movements and make them move properly:
\begin{itemize}\itemsep1pt \parskip0pt \parsep0pt
\item State 0 is when a vehicle is not moving
\item State 1 means that the vehicle is moving straight.
\item State 2 means that the vehicle has entered an intersection
\item State 3 is a state where the vehicle has been deleted or has exited the simulation.
\end{itemize} 

\subsection{Evolution of Vehicle Drawing and Animation}
\paragraph{}
Our vehicle movement evolved over the course of the project, with many improvements made along the way. 
\subsubsection{First Implementation}
\paragraph{}
After the map's grid was able to be drawn dynamically, the vehicle now had to move on top of the lanes. It was challenging at first because the obvious way of having the vehicle move between grid cells is not possible. The first step towards our solution was having a rectangle representing the vehicle fill the whole grid cell, regardless of whether it is moving vertically or horizontally. The location of where the rectangle should go was determined by a formula, which took its original placement in the map. The coordinate x- and y-positions of the vehicle are multiplied by the image dimension and the resize factor. The actual movement of the vehicle is dependent on the map direction it is coming from and the map direction it is going to. So if a vehicle is moving east, then north, that means it is turning left and a left turn animation is required. A JavaFX TranslateTransition is used to move the vehicle.
\paragraph{}
However, turning the vehicle was quite complex. In the first implementation, a vehicle would simply shift into its new location, so a different edge of the vehicle would now be moving forwards. That did not lend itself to a realistic simulation. Additionaly, because of the different kinds of cases of movement, like east to north, west to south, et cetera, we had a lot of duplicated code with only a few values changed in each case. Furthermore, the nature of the animation was shifting it by some x and y values relative to where the vehicle currently is. This made the animation imprecise and over time, vehicles would shift out of their lanes and start moving on grass or on top of other lanes. As a consequence, this kind of animation only worked with a ticker speed of 1000ms. If the ticker was made faster, the animation would become more imprecise, with vehicles not reaching the cells they should have in time. This approach worked well in a very limited amount of cases and needed to be reworked to work with a variety of ticker speeds and many vehicles. This brought us to our second implementation of vehicle movement.

\subsubsection{Second Implementation (Current)}
\paragraph{}
Because of all the issues with the first vehicle movement, namely vehicles shifting out of place and not working with various ticker speeds, we re-worked the animation to a much simpler process. The process is:
\begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt
\item Get the current coordinate location of the vehicle
\item Calculate the new coordinate location for the vehicle
\item Calculate the required vehicle rotation based on where it is moving from and to
\item Determine the actual pixel locations for the new location
\item Set the movement translation to an exact location
\item Move and rotate the vehicle
\end{enumerate}
There are helper methods to calculate some of the steps. The method "directionToTranslation(MapDirection d)" takes a MapDirection and translates it into a coordinate representing a movement in that direction. For example, passing in a parameter of EAST returns a Coordinate with the value of (1,0). The method "getRotationFromDirectionChange(...)" takes the direction the vehicle is moving from and to as parameters and returns the angle which the vehicle must turn by. Most importantly, the method "coordinateToPixels(Coordinate c, MapDirection d)" takes a location in the map and a direction as parameters and returns the exact location to where the vehicle must move to. It is also used to determine the initial location of the vehicle. The MapDirection parameter makes sure that the vehicle gets drawn in the correct lane.

\paragraph{}
There are many advantages to this second implementation. First, there was a drastic reduction in code duplication. The process was converted to a set of simple steps which works in any situation. In addition, because of each coordinate having a distinct location, the vehicle knows exactly where go. This makes it work flawlessly with any ticker speed. Finally, the vehicle does not shift out of its lanes over time. 

\subsection{Simulation Statistics}
We have a couple of traffic management policies. These are:
\begin{itemize}\itemsep1pt \parskip0pt \parsep0pt
\item Changing the duration of traffic lights
\item Disabling or enabling traffic lights
\item Increasing or decreasing the number of vehicles
\end{itemize}
\paragraph{}
By doing these three things, the effect of them can be seen in the "Vehicle Time Spent Standing" statistic. This is a percentage that gets calculated using all the vehicles in the map. Each vehicle has two variables associated with it for the calculation of this statistic: timeSpentStanding and timesTicked. Each time the vehicle was unable to move, its timeSpentStanding increases. A vehicle is unable to move if it is at a red light or if there was a vehicle in the slot in front of it. The increment happens in the  VehicleController class when the "move" result is zero, i.e., it could not move forwards.
\begin{lstlisting}
	if(move == 0) {
		Vehicle thisVehicle = vehicleGUIDecorator.getVehicle();
		thisVehicle.incrementTimeSpentStanding();
	}
\end{lstlisting}
\paragraph{}
For the percentage calculation, there is a local subscriber to the ticker in the SimulationScreen class. It is used for doing any operation when the ticker ticks, like increasing the "Times Ticked" label and calculating this statistic. Each time the ticker ticks, the method "getPercentageStanding()" is called and the output is set to the label.
\paragraph{}
In this method, the VehicleController gets queried for two values: the total time spent standing for all vehicles and the total times ticked for all vehicles. Each method gives the sum of all timeSpentStanding and timesTicked, respectively. 
\begin{lstlisting}
	int timeSpentStanding = VehicleController.getTotalTimeSpentStanding();
	int totalTimesTicked = VehicleController.getTotalTimesTicked();
\end{lstlisting}
\paragraph{}
To get the average time spent standing statistic, the following calculation is made:
\begin{lstlisting}
	double ans = (double) timeSpentStanding / totalTimesTicked * 100;
	return Math.round(ans * 100.0) / 100.0;
\end{lstlisting}
\paragraph{}
This statistic can tell us about the amount of congestion on the roads and how external factors like traffic lights can affect vehicle movement over time.

\subsubsection{Interesting Trends}
\paragraph{}
Many interesting trends to this statistic can be observed by manipulating the three controls available:
\begin{itemize}\itemsep1pt \parskip0pt \parsep0pt
\item The more vehicles there are, the higher the percentage of vehicle time spent standing is.
\item When holding the simulation conditions stable (e.g. keeping a constant number of vehicles, not changing traffic light duration), the percentage of vehicle time spent standing stabilizes over time and does not differ by about one percentage.
\item Increasing the duration of traffic lights increases the percentage of vehicles standing, and decreasing the duration of traffic lights decreases the percentage of vehicle time spent standing.
\item Disabling traffic lights does not completely bring the percentage of vehicle time spent standing to zero. This is because there may still be other vehicles getting in the way.
\item Setting the number of vehicles to zero resets the statistic because every car in the simulation is new.
\item Adding one more vehicle to the simulation does not affect the statistic significantly.
\end{itemize}

\section{Map Maker Mode}
\subsection{Map Making Basics}
\paragraph{}
To make our system more flexible to different kinds of maps, we allow the user to build their own maps to run the simulation on if they do not like any of the pre-made maps. When starting the system, if the user chooses to "Make a new Map", they are prompted to choose a width and height. To prevent maps that are too small or large to view, the width and height are limited to the range of 5 to 30. An empty map of the width and height that they chose is generated. The user can then proceed to put map components into the grid by clicking on the desired component and clicking to where on the map they want the component to be. Map components include: intersections, roads that run vertically (North-South), roads that run horizontally (East-West), and grass (an empty/null, square). Roads are always added with a lane going in each direction. If a component was placed in a square by accident, the "grass" component can be added to empty that square. When the user finishes, they can press the "Save Map" button to save the map to disk. If the user does not like their map, the "Reset Map" button removes all components from the map. If they decide to not build a map anymore, the "Go Back" button brings them back to the mode selection screen. 

\subsection{Implementation}
\paragraph{The Empty Map}
The empty map is represented by the Map class, which contains the MapGrid of no components. To allow clicking on the map, we traverse through the map, visiting each cell, and adding an on-click listener to each cell. Since the Map is represented by a JavaFX GridPane, getting the node to add the on-click listener to at the specified location was not trivial. We included a function called "getNodeFromIndex" that takes the x- and y-coordinates and the GridPane as parameters. It gets the node by looking throught all the children of each GridPane cell, and if that Node's location equals the location that we requested, that Node from the GridPane is returned. Now we know when the user clicks on the map to place a map component.
\paragraph{Placement of Map Components}
When the user selects a component from the right of the screen and clicks on a location in the map, an instance of that component is actually created in the map. For instance, when placing an intersection in the map, an Intersection object gets created and placed in that space. It is set with no roads attached and no traffic lights. When placing a bit of road, either North-South or East-West, an instance of the Road class is created every time. The Road instance's start and end coordinate locations are the same, so a road of length 1 is created. Two lanes are added, with each going in opposite directions.
\paragraph{Keeping Focus}
At first, building maps was a very annoying task. The user would have to click on the map component on the right, then click on the empty grid square, then go back to click on the map component again, followed by an empty grid square, and so on. This was solved by tracking of what on the screen gets focus and what held the focus previously. Focus means what was last clicked or selected  by the user, that is, the mouse cursor was "focused" on a specific element on the screen. The focus is represented by a Java enum, with entries like ROADNS (for a road that travels vertically) and INTERSECTION. 
\paragraph{}
When this mode starts up, the current focus is set to nothing, and the previous is null. The values are stored in the MapMakerController. As an example, if the user first clicks on the Intersection component image, that image gains focus. A blue glow surrounds the image to represent focus. If the user then clicks on an empty map grid square, that map grid square gains focus and the previous focused gets set to Intersection. The map grid checks was was previously focused. It will see that Intersection was previously focused, and place the component in the clicked map grid square. However, to make it easier on the user, focus is then placed back on the Intersection component image so they can keep clicking intersections into the map. The same applies for all other component images. 
\paragraph{Saving the Map}
When the user decides to save the map, they first get prompted for a file name. The file name cannot be empty, and this is enforced by disabling the "OK" button in the Save dialog while the textfield is empty. When the user hits the "OK" button, the saving process begins. Because of the way the map components were placed into the map, all the roads are separate and disconnected and all intersections are not connected to any roads. In other words, if there is a road of length 5 moving vertically, there are actually 5 separate roads moving vertically. We need to "glue" together all the bits of roads, connect those roads to the relevant intersections, and add all traffic lights. 
\paragraph{}
The method in the MapMakerScreen class called "buildAndSaveMap(Map m)" takes the map "m" that the user built. Using that map's width and height, a new empty map is created that will serve as the "glued together" and final verison of the user built map. We traverse the broken map, and when we discover a component, we process it. Discovering an intersection is the simplest case. We remove the intersection from the old map and place a new intersection into the old map at the same location. For bits of Road instances, it is trickier. If we discover a bit of road that is moving horizontally (east-west), we then have a while loop moving down the map row to see how long the road is. This way we determine the start location of this road (the original found piece) and the end location of this road (the last bit of road that was not null). We create a new road, add 2 lanes, remove all the bits of road from the old map (so they do not get added to the fixed map twice), and add the new road to the new map. A similar process is done for roads moving vertically. Each time a new stretch of road bits is discovered in the old map, this process is followed to "glue" all road sections together.
\paragraph{}
Now that we added all Roads and Intersections to the new map, we must connect the "edges" and "nodes" of our map, i.e. our roads and intersections. The method "assignRoadsToIntersections(Map m)" takes the fixed map that we just built as a parameter. We retrieve the list of all intersections from the map and determine the surrounding coordinates for that intersection. If there is a road component in any of the coordinates, the intersection gets assigned that road. For example, if there is a Road component north of the intersection, that road gets assigned as the north road of that intersection. This is done for all intersections. Now that all roads are glued and all intersections have been assigned roads, the map can now finally be saved to disk using serialization.
\paragraph{Map Validation and Robustness}
When saving the map, there is no map validation. We do not check whether all roads connect to some intersection and that no intersections are floating alone with no roads. Therefore, the user is able to build any meaningless map. However, this is fine. The simulation is robust against these kinds of map designs by having the vehicles behave in appropriate ways. For instance, if there is a road without an intersection at the end of it, the vehicle simply leaves the simulation. If there is a road connected to an intersection, but no other roads to go to, the vehicle simply stays in place once it reaches the intersection because it has nowhere else to go. So overall, no matter how poorly built the map is, the vehicles will act accordingly and there will be no system crashes.

\subsection{Evaluation}
Although the map building process was optimized by keeping focus and quick map component placement, there are a few areas where the process could have been improved. Some sort of click-and-drag functionality would make it easier to place a lot of components in big maps. Some of the non-GUI functionality helper methods could have been moved to the controller to keep GUI and logical methods separate. When saving the map, we should have probably checked if each newly discovered adjacent road is moving in the same direction as the first piece of discovered road. Some map validation would be nice to have, regardless of how robust the system is. Finally, a dialog saying where the map was saved to would be useful so the user would know exactly where to look when trying to load their map for the simulation screen.

\part{Teamwork}
\section{Communication}
\paragraph{}
We use WhatsApp for general communication, like coordinating meeting times. We use Slack for project discussion, like discussing new ideas/problems and sharing documents. We have general discussion for all group members and private communication between two members to talk about issues like program interfaces without bothering others.

\section{Group meetings}
\paragraph{}
We have scheduled group meetings twice a week, mostly on Monday and Friday. We discussed task progress and assigned new tasks normally on Monday. On Friday, there would be a long-duration meeting. we would talk about the project in detail and members would code together.
\section{Agile development with Mingle}
\paragraph{}
Because of the nature of the project, continuous learning and adaptation to the emergent state of the project are unavoidable. We use Mingle for project management which is based on Agile software development principles. It is designed to integrate with a team's workflow. We used Mingle's Planner feature to define objectives for each team member, track a plan's progress, and receive alerts when a plan changes. Mingle helps our team communicate intentions, collaborate easily, and effectively solve problems by having more efficient conversations with team members.
\paragraph{}
At the task level, Mingle allows us to assign teammates to a specific action, so everyone can see who is working on what. At the end of our group meetings, we will assign tasks to group members by adding a new story at Mingle planner including a specific task description, an estimate duration, status (new, in progress, complete), a task priority (must, should could), the owner of the task. 
\paragraph{}
At the project level, we use Mingle to start a conversation if an upcoming deadline has not been met. We often talked about a task's status to have a better grasp about how is the progress going.
\paragraph{}
At the program level, Mingle sends us alerts so that everyone can follow up. We also exported the task file and uploaded to Github to make it available and more convenient for everyone to check their tasks at any time.
 
\subsection{Github}
\paragraph{}
IntelliJ is our main platform for coding. We use Github as our main source-code repository. We have a master branch and four personal branches. Everyone is free to experiment and commit changes. Anything in the master branch is always deployable. Branches aren't merged until the change was reviewed. Once we have done our tasks, we commit and add an associated commit message, which is a description explaining why a particular change was made. The master branch would close a merge request and sometimes roll back changes if a bug was found, since each commit is considered a separate unit of change. Our Slack chat was configured to include a GitHub bot to tell us when changes were made. Our team became very proficient at Git over the course of development.

\part{General Project Evaluation}
\section{Things that went well}
\paragraph{}
We had clear goals for each development stage, i.e. what must/should/could be achieved for each iteration. Before and after each iteration, we would check and make sure everything has been achieved. This ensures our entire development process is progressing well. By following Agile development principles, our team did a good job responding to unpredictability through incremental and iterative work. 
\paragraph{}
From the perspective of software development, we adhered to the MVC architecture. We have clear hierarchical model structures, e.g., a map contains roads and intersections, traffic light and lane are owned by intersection and road respectively.
\paragraph{}
We made the system a user-friendly application. Users can monitor and control the simulation process by going into simulation mode. The map maker mode allows users to design maps with any dimensions or map components. A simulation log is available after each simulation for users to analyze the whole simulation process. 
\paragraph{}
In general, we worked well as a team, with each member focusing on a roughly different aspect of the system. There were no major conflicts and everyone understood the importance of good, hard work for this project.

\subsection{Things that did not go well and what we did}
We had many difficulties along the way, but we always managed to pull through and resolve them. The ticker went through several iterations itself, with improvements being made each time. The animation started off basic, which also got improved several times over the course of the project. Bugs like traffic lights not working in loaded maps got fixed promptly. And finally, the resize factor used to display maps poorly, but now does a good job for all map sizes.

\subsection{Possibilities for the future}
\paragraph{}
It is impossible to implement all ideas we had because of short term. In the future, we can add more vehicle types like police cars, bicycles, buses, etc. as well as more road types including railroads and overpasses. There can be arc intersections instead of cross intersections. We can make our system adapt to real maps like Google Maps. By providing a real location, users can get traffic situations through our system. By connecting background log files to real maps, it would be possible to deliver these log files to real traffic monitoring stations for furthter-step traffic analysis.

\part{Peer Assessment}
\paragraph{}
We have decided to distribute the points as follows:
\begin{center}
\begin{tabular}{ l | c }
  Name & Points \\ \hline
  Violetta & 20.0 \\
  Santiago & 20.0 \\
  Rawan & 20.0 \\
  Yakubu & 20.0 \\ 
  Jia & 20.0\\ \hline \hline
  Total & 100.0\\
  \hline
\end{tabular}
\end{center}
\paragraph{}
We distributed the points evenly because we believe that each member contributed a lot to the project. Each person has something that they implemented and was their idea, and many hours were spent by all on this project.

\newpage
\bibliographystyle{plain}
\bibliography{literature}

\appendix
\part{Appendix}
\section{Git Log}
\input{gitlog}

\section{Source Code}
\includepdf[pages=-]{output-letter}

\end{document}
